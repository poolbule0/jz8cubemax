# JZ8P1521 配置修复 - 修改对比

## 修改 1：TCC 分频配置（init_generator.py）

### 修改前

```python
def _generate_tcc_init_code(self) -> List[str]:
    """生成TCC定时器初始化代码（JZ8P1521）- 只生成函数体"""
    code = []
    config = self.config_data["timer"]["TCC"]

    # CONT寄存器计算
    # Bit2-0: 预分频比（0-7对应1:2到1:256）
    # Bit4: 边沿选择（0=上升沿，1=下降沿）
    # Bit5: 时钟源选择（0=内部，1=外部）
    cont_value = 0x00
    prescaler_val = config["prescaler"] & 0x07
    cont_value |= prescaler_val
    
    if config.get("edge", "rising") == "falling":
        cont_value |= 0x10
    
    if config["clock_source"] == "external":
        cont_value |= 0x20
    
    # 使用CONTW宏设置CONT寄存器
    self._add_code_with_comment(code, f"\tCONTW(0x{cont_value:02X});", 
                                f"TCC预分频\t;预分频比={prescaler_val}")
    # ? 问题：注释显示的是索引值（0-7），而不是实际分频比（1:2 到 1:256）
```

### 修改后

```python
def _generate_tcc_init_code(self) -> List[str]:
    """生成TCC定时器初始化代码（JZ8P1521）- 只生成函数体"""
    code = []
    config = self.config_data["timer"]["TCC"]

    # CONT寄存器计算
    # Bit2-0: 预分频比（0-7对应1:2, 1:4, 1:8, 1:16, 1:32, 1:64, 1:128, 1:256）
    # Bit4: 边沿选择（0=上升沿，1=下降沿）
    # Bit5: 时钟源选择（0=内部，1=外部）
    # 注意：CONT寄存器的值直接对应分频系数，不需要额外计算
    cont_value = 0x00
    prescaler_val = config["prescaler"] & 0x07
    cont_value |= prescaler_val
    
    if config.get("edge", "rising") == "falling":
        cont_value |= 0x10
    
    if config["clock_source"] == "external":
        cont_value |= 0x20
    
    # 使用CONTW宏设置CONT寄存器
    # 分频比对应关系：0=1:2, 1=1:4, 2=1:8, 3=1:16, 4=1:32, 5=1:64, 6=1:128, 7=1:256
    prescaler_ratio = [2, 4, 8, 16, 32, 64, 128, 256][prescaler_val]
    self._add_code_with_comment(code, f"\tCONTW(0x{cont_value:02X});", 
                                f"TCC预分频\t;预分频比=1:{prescaler_ratio}")
    # ? 修复：现在显示正确的分频比（如"预分频比=1:16"）
```

### 生成代码对比

**修改前：**
```c
CONTW(0x03);  // TCC预分频 ;预分频比=3
```

**修改后：**
```c
CONTW(0x03);  // TCC预分频 ;预分频比=1:16
```

---

## 修改 2：Sleep 唤醒配置（sleep_generator.py）

### 修改前

```python
# 配置P6端口唤醒使能（RD寄存器/ICIECR）
wake_ports = cfg.get("wake_ports", [])
rd_value = 0x00
if wake_ports:
    # 根据配置的端口设置RD寄存器（ICIECR）
    # Bit0-7对应P60-P67的唤醒使能
    for port in wake_ports:
        if port.startswith("P6"):
            try:
                pin_num = int(port[2:])
                if 0 <= pin_num <= 7:
                    rd_value |= (1 << pin_num)
            except ValueError:
                pass

if rd_value != 0:
    self._add_code_with_comment(code, f"{indent}\tRD = 0x{rd_value:02X};", 
                               "P6端口状态变化唤醒使能\t;0禁止，1使能")

self._add_code_with_comment(code, f"{indent}\tIOCP_W(IMR, 0x{iocf_value:02X});", 
                           "使能端口变化中断，不使能无法唤醒")
```

**问题：**
- ? 没有检查是否真正配置了端口变化唤醒
- ? RD 寄存器的配置逻辑不完整

### 修改后

```python
# 配置P6端口唤醒使能（RD寄存器/ICIECR）
# 根据手册：RD寄存器（ICIECR）用于配置P6端口状态变化唤醒使能
# Bit0-7对应P60-P67的唤醒使能，0=禁止，1=使能
wake_ports = cfg.get("wake_ports", [])
rd_value = 0x00
if wake_ports:
    # 根据配置的端口设置RD寄存器（ICIECR）
    for port in wake_ports:
        if port.startswith("P6"):
            try:
                pin_num = int(port[2:])
                if 0 <= pin_num <= 7:
                    rd_value |= (1 << pin_num)
            except ValueError:
                pass

# 如果配置了端口变化唤醒，需要设置RD寄存器
if wakeup_config.get("port_change", False) and rd_value != 0:
    self._add_code_with_comment(code, f"{indent}\tRD = 0x{rd_value:02X};", 
                               "P6端口状态变化唤醒使能\t;0禁止，1使能")

# 配置唤醒中断使能（IMR寄存器）
# 注意：必须先设置RD寄存器，再设置IMR中的ICIE位才能使端口变化中断唤醒生效
self._add_code_with_comment(code, f"{indent}\tIOCP_W(IMR, 0x{iocf_value:02X});", 
                           "使能端口变化中断，不使能无法唤醒")
```

**改进：**
- ? 添加了对 `wakeup_config.get("port_change", False)` 的检查
- ? 只在真正配置了端口变化唤醒时才设置 RD 寄存器
- ? 添加了详细的注释说明配置顺序的重要性

---

### 修改前：唤醒后恢复

```python
# 睡眠唤醒后恢复
self._add_comment(code, "------------睡眠唤醒----------------------")

# 关闭中断
self._add_code_with_comment(code, f"{indent}\tIOCP_W(IMR, 0x00);", "关闭中断")

# 重新初始化TCC定时器（如果使能）
timer_config = self.config_data.get("timer", {})
if timer_config.get("TCC", {}).get("enabled", False):
    code.append(f"{indent}\tfw_tc0Init();")

# 恢复中断使能
interrupt_config = self.config_data.get("interrupt", {})
iocf_restore = 0x00
# ... 计算 iocf_restore ...

if iocf_restore != 0:
    code.append(f"{indent}\tIOCP_W(IMR, 0x{iocf_restore:02X});")

# 使能中断
code.append(f"{indent}\tEI();")

# 清中断标志位
code.append(f"{indent}\tISR = 0;")
```

**问题：**
- ? 先关闭中断，再初始化定时器（顺序不对）
- ? 最后才清除中断标志位（应该先清除）

### 修改后：唤醒后恢复

```python
# 睡眠唤醒后恢复
self._add_comment(code, "------------睡眠唤醒----------------------")

# 重新初始化TCC定时器（如果使能）
# 注意：必须在恢复中断前重新初始化定时器
timer_config = self.config_data.get("timer", {})
if timer_config.get("TCC", {}).get("enabled", False):
    code.append(f"{indent}\tfw_tc0Init();")

# 清中断标志位（清除唤醒时产生的中断标志）
self._add_code_with_comment(code, f"{indent}\tISR = 0x00;", "清中断标志位")
code.append("")

# 恢复中断使能
interrupt_config = self.config_data.get("interrupt", {})
iocf_restore = 0x00
# ... 计算 iocf_restore ...

if iocf_restore != 0:
    self._add_code_with_comment(code, f"{indent}\tIOCP_W(IMR, 0x{iocf_restore:02X});", "恢复中断使能")

# 使能中断
code.append(f"{indent}\tEI();")
```

**改进：**
- ? 正确的顺序：初始化定时器 → 清除标志位 → 恢复中断 → 使能全局中断
- ? 先清除中断标志位，再恢复中断使能
- ? 添加了详细的注释说明每一步的目的

---

## 生成代码对比

### 修改前的 sleep.c（部分）

```c
// 睡眠前准备
LVDCON = 0;           // 关LVD
IOCP_W(IMR, 0x00);    // 关闭中断
IOCP_W(WDTCR, 0x00);  // 关闭看门狗
ISR = 0;              // 清中断标志位
DI();                 // 禁止唤醒进入中断

// 配置唤醒源
RD = 0x06;            // P6端口状态变化唤醒使能
IOCP_W(IMR, 0x02);    // 使能端口变化中断

SLEEP();
NOP();
NOP();
NOP();
NOP();
CWDT();

// 睡眠唤醒后恢复
IOCP_W(IMR, 0x00);    // ? 关闭中断（不应该在这里）
fw_tc0Init();         // 重新初始化TCC定时器
IOCP_W(IMR, 0x03);    // 恢复中断使能
EI();                 // 使能中断
ISR = 0;              // ? 最后才清除标志位（顺序错误）
```

### 修改后的 sleep.c（部分）

```c
// 睡眠前准备
LVDCON = 0;           // 关LVD
IOCP_W(IMR, 0x00);    // 关闭中断
IOCP_W(WDTCR, 0x00);  // 关闭看门狗
ISR = 0;              // 清中断标志位
DI();                 // 禁止唤醒进入中断

// 配置唤醒源
RD = 0x06;            // P6端口状态变化唤醒使能
IOCP_W(IMR, 0x02);    // 使能端口变化中断

SLEEP();
NOP();
NOP();
NOP();
NOP();
CWDT();

// 睡眠唤醒后恢复
fw_tc0Init();         // ? 先重新初始化TCC定时器
ISR = 0x00;           // ? 清中断标志位（清除唤醒时产生的中断标志）
IOCP_W(IMR, 0x03);    // ? 恢复中断使能
EI();                 // ? 使能中断
```

---

## 总结

| 项目 | 修改前 | 修改后 |
|------|--------|--------|
| **TCC 分频注释** | 显示索引值（0-7） | 显示实际分频比（1:2 到 1:256） |
| **RD 寄存器配置** | 无条件设置 | 仅在配置端口变化唤醒时设置 |
| **唤醒恢复顺序** | 先关中断，后清标志 | 先初始化，清标志，再恢复中断 |
| **代码注释** | 基础 | 详细说明配置要点 |
| **符合手册** | ? 部分不符 | ? 完全符合 |

这些修改确保生成的代码完全符合 JZ8P1521 数据手册的规范。

